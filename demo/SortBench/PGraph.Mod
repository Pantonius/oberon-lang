MODULE PGraph;(*      Graphik-Rahmenprogramm für Turtle-Graphik   Fabian Mäser, 18.4.95   SPARC-Oberon V4 Release 2.8   zuletzt geändert: 24.6.96   -> WICHTIG: Das fuer den OS-Buffer verwendete Modul "Pictures" ist ein "Hack".      Auf anderen Platformen muss dieses Modul mit derselben Schnittstelle vorhanden sein,      ausserdem muss die Konstante "BitsPerPixel" angepasst werden.      Dieses Modul funktioniert auf SPARC, Ceres.*)IMPORT Oberon, TextFrames, MenuViewers, Viewers, Display, Math, Printer, Pictures, Log;CONST   MaxX* = 720;      (* Offscreen buffer size (Ceres: 640x800) *)   MaxY* = 860;   white* = Display.white;   black* = Display.black;   ZweiPi = 6.2831853;   FrameName = "PGraph";   MenuString = "System.Close System.Copy System.Grow PGraph.Clear PGraph.Print";   BitsPerPixel = 8;   (* SPARC-Oberon (Ceres = 1 bit) *)   CeresPrinter = "Pluto";   SPARCPrinter = "lpe1";   ZoomFactor = 2;TYPE   Frame = POINTER TO FrameDesc;   (* Graph-Frame *)   FrameDesc = RECORD (Display.FrameDesc) END;   ColorMsg = RECORD (Display.FrameMsg)      color: INTEGER;   END;   UpdateMsg = RECORD (Display.FrameMsg)      x, y, w, h: INTEGER;   (* update region *)   END;VAR   gPict: Pictures.Picture;   (* global offscreen buffer -> model for all graph viewers *)   gTurtleData: RECORD      x, y: REAL;      direction: REAL;      penDown: BOOLEAN;      color: INTEGER;   END;(* ---   Auxiliary Procs   --- *)PROCEDURE DegToRad(grad: REAL): REAL;BEGIN   WHILE grad < 0 DO grad := grad + 360 END;   WHILE grad > 360 DO grad := grad - 360 END;   RETURN (grad * ZweiPi) / 360;END DegToRad;PROCEDURE Min(x, y: INTEGER): INTEGER;BEGIN   IF x < y THEN RETURN x ELSE RETURN y ENDEND Min;PROCEDURE Max(x, y: INTEGER): INTEGER;BEGIN   IF x > y THEN RETURN x ELSE RETURN y ENDEND Max;PROCEDURE Round(x: REAL): INTEGER;BEGIN   RETURN SHORT(ENTIER(x + 0.5));END Round;(* ---   Picture Ops:   --- *)(*   NOTE: these procedures do NOT check whether given coordinates are legal!*)PROCEDURE Dummy(p: Pictures.Picture; x, y, w, h: INTEGER);(* used as Notifier in Pictures.Picture *)BEGINEND Dummy;PROCEDURE ResetColor* (color: INTEGER);(* set all pixels to "color" *)VAR msg: ColorMsg;BEGIN   Pictures.ReplConst(gPict, color, 0, 0, gPict.width, gPict.height, Display.replace);   msg.color := color; Viewers.Broadcast(msg);END ResetColor;PROCEDURE Flush* (x, y, w, h: INTEGER);(* update all viewers within picture coords (x, y, w, h) *)VAR msg: UpdateMsg;BEGIN   msg.x := x; msg.y := y; msg.w := w; msg.h := h;   Viewers.Broadcast(msg);END Flush;PROCEDURE FlushAll*;(* update all viewers *)VAR msg: UpdateMsg;BEGIN   msg.x := 0; msg.y := 0; msg.w := MaxX; msg.h := MaxY;   Viewers.Broadcast(msg);END FlushAll;PROCEDURE Dot* (x, y, color: INTEGER);BEGIN   Pictures.Dot(gPict, color, x, y, Display.replace);END Dot;PROCEDURE ReplConst* (x, y, w, h, color: INTEGER);BEGIN   Pictures.ReplConst(gPict, color, x, y, w, h, Display.replace);END ReplConst;PROCEDURE DrawLine* (x1, y1, x2, y2, color: INTEGER);(* Bresenham-Algorithmus aus Nievergelt/Hinrichs: "Algorithms & Data Structures *)VAR   dx, dy, sx, sy, d, x, y: INTEGER;BEGIN   x := x2 - x1;   y := y2 - y1;   IF x > 0 THEN      sx := 1;   ELSE      sx := -1;   END;   IF y > 0 THEN      sy := 1;   ELSE      sy := -1;   END;   dx := ABS(x);   dy := ABS(y);   x := x1;   y := y1;   IF dx > dy THEN      d := 2 * dy - dx;      Pictures.Dot(gPict, color, x, y, Display.replace);      WHILE x # x2 DO         IF (d > 0) OR ((d = 0) & (sy = 1)) THEN            y := y + sy;   d := d - 2 * dx;         END;         x := x + sx;   d := d + 2 * dy;         Pictures.Dot(gPict, color, x, y, Display.replace);      END;   ELSE      d := 2 * dx - dy;      Pictures.Dot(gPict, color, x, y, Display.replace);      WHILE y # y2 DO         IF (d > 0) OR ((d = 0) & (sx = 1)) THEN            x := x + sx;   d := d - 2 * dy;         END;         y := y + sy;   d := d + 2 * dx;         Pictures.Dot(gPict, color, x, y, Display.replace);      END   END;END DrawLine;(* ---   Turtle Graphics   --- *)PROCEDURE TurtleReset*;   (* default turtle values *)BEGIN   gTurtleData.x := MaxX / 2; gTurtleData.y := MaxY / 2;   gTurtleData.direction := 0; gTurtleData.penDown := TRUE;   gTurtleData.color := white;END TurtleReset;PROCEDURE PenDown*;BEGIN   gTurtleData.penDown := TRUE;END PenDown;PROCEDURE PenUp*;BEGIN   gTurtleData.penDown := FALSE;END PenUp;PROCEDURE Forward* (x: REAL);VAR dx, dy: REAL;BEGIN   dx := x * Math.cos(DegToRad(gTurtleData.direction));   dy := x * Math.sin(DegToRad(gTurtleData.direction));   IF gTurtleData.penDown THEN      DrawLine(Round(gTurtleData.x), Round(gTurtleData.y), Round(gTurtleData.x + dx),                  Round(gTurtleData.y + dy), gTurtleData.color)   END;   gTurtleData.x := gTurtleData.x + dx; gTurtleData.y := gTurtleData.y + dy;END Forward;PROCEDURE Turn* (grad: REAL);BEGIN   gTurtleData.direction := gTurtleData.direction + grad;   WHILE gTurtleData.direction > 360 DO gTurtleData.direction := gTurtleData.direction - 360 END;   WHILE gTurtleData.direction < 0 DO gTurtleData.direction := gTurtleData.direction + 360 END;END Turn;PROCEDURE SetPos* (x, y: REAL);BEGIN   gTurtleData.x := x; gTurtleData.y := y;END SetPos;PROCEDURE GetPos* (VAR x, y: REAL);BEGIN   x := gTurtleData.x; y := gTurtleData.y;END GetPos;PROCEDURE SetDirection* (grad: REAL);BEGIN   gTurtleData.direction := grad;   WHILE gTurtleData.direction > 360 DO gTurtleData.direction := gTurtleData.direction - 360 END;   WHILE gTurtleData.direction < 0 DO gTurtleData.direction := gTurtleData.direction + 360 END;END SetDirection;PROCEDURE SetColor* (color: INTEGER);(* set the color used by the turtle *)BEGIN   gTurtleData.color := colorEND SetColor;(* ---   Graph Frames   --- *)PROCEDURE Update(F: Frame; x, y, w, h: INTEGER);(*   update the Frame within picture coords (x, y, w, h):   the upper left corner of the picture is always the upper left corner of the frame*)VAR   width, pictY, dy: INTEGER;BEGIN   IF (x < F.W) & (y+h > MaxY - F.H) THEN   (* coords within frame *)      width := Min(F.W - x, w);   (* visible width of picture*)      pictY := Max(MaxY - F.H, y);   (* visible y0-coord of picture *)      IF y < pictY THEN h := h + y - pictY END;   (* visible height of picture *)      dy := F.H - MaxY;   (* y-difference between frame and picture *)      Pictures.DisplayBlock(gPict, x, pictY, width, h, F.X+x, F.Y + pictY + dy, Display.replace);   END;END Update;PROCEDURE Modify (F: Frame; Y, H: INTEGER);(* frame size (y-coordinates) has changed... *)BEGIN;   F.Y := Y; F.H := H;   IF F.H > MaxY THEN Display.ReplConst(black, F.X, F.Y, F.W, F.H - MaxY, Display.replace) END;   IF F.W > MaxX THEN Display.ReplConst(black, F.X + MaxX, F.Y, F.W - MaxX, F.H, Display.replace) END;   Update(F, 0, 0, MaxX, MaxY);   (* not necessary to update all but fast enough *)END Modify;PROCEDURE Copy (src, dst: Frame);BEGIN   dst^ := src^;END Copy;PROCEDURE Handle (f: Display.Frame; VAR Msg: Display.FrameMsg);VAR F, CopyOfF: Frame;BEGIN   F := f(Frame);   IF Msg IS Oberon.InputMsg THEN      WITH Msg: Oberon.InputMsg DO         IF Msg.id = Oberon.track THEN            Oberon.DrawCursor(Oberon.Mouse, Oberon.Arrow, Msg.X, Msg.Y)         END      END   ELSIF Msg IS Oberon.CopyMsg THEN      WITH Msg: Oberon.CopyMsg DO         NEW(CopyOfF); Copy(F, CopyOfF); Msg.F := CopyOfF      END   ELSIF Msg IS MenuViewers.ModifyMsg THEN      WITH Msg: MenuViewers.ModifyMsg DO Modify(F, Msg.Y, Msg.H) END   ELSIF Msg IS ColorMsg THEN      WITH Msg: ColorMsg DO         Update(F, 0, 0, MaxX, MaxY);      END   ELSIF Msg IS UpdateMsg THEN      WITH Msg: UpdateMsg DO         Update(F, Msg.x, Msg.y, Msg.w, Msg.h);      END   ENDEND Handle;(* ---   user commands:   --- *)PROCEDURE OpenGraphViewer*;VAR F: Frame; V: Viewers.Viewer; x, y: INTEGER;BEGIN(*   *** Allocate a new Track --- disabled 23.4.96 ***   x := Oberon.UserTrack(Oberon.Mouse.X);   Oberon.OpenTrack(x, Oberon.SystemTrack(Oberon.Mouse.X) - x);*)   NEW(F);   F.handle := Handle;   Oberon.AllocateUserViewer(Oberon.Mouse.X, x, y);   V := MenuViewers.New(TextFrames.NewMenu(FrameName, MenuString), F, TextFrames.menuH, x, y);END OpenGraphViewer;PROCEDURE Clear*;(* the user command to set all to "background" *)BEGIN   ResetColor(black)END Clear;PROCEDURE Print*;(* print the picture -> choose the correct printer name! *)VAR   printerName: ARRAY 10 OF CHAR;   x, y: INTEGER;BEGIN   printerName := SPARCPrinter;   Printer.Open(printerName, Oberon.User, Oberon.Password);   IF Printer.res = 0 THEN (* ok *)      Log.Str("printing..."); Log.Ln;      x := (Printer.PageWidth - ZoomFactor * MaxX) DIV 2;      y := (Printer.PageHeight - ZoomFactor * MaxY) DIV 2;(*      Printer.ReplConst(x-1, y-1, ZoomFactor * MaxX, 1);   (* draw border *)      Printer.ReplConst(x-1, y-1, 1, ZoomFactor * MaxY);      Printer.ReplConst(x + ZoomFactor * MaxX + 1, y+1, 1, ZoomFactor * MaxY);      Printer.ReplConst(x-1, y + ZoomFactor * MaxY + 1, ZoomFactor * MaxX, 1);*)      Printer.Picture(x DIV ZoomFactor, y DIV ZoomFactor, MaxX, MaxY, ZoomFactor, Pictures.Address(gPict));   (* ***** *)      Printer.Page(1);      Printer.Close;   ELSE      Log.Str("PGraph.Print: ERROR - no printer found"); Log.Ln;   ENDEND Print;BEGIN (* PGraph *)(*   Init the global Pictures.Picture (offscreen buffer):      - the Notifier is not needed (whatever it is supposed to do... ;-)      - the "depth" field must be equal to the number of bits used for a pixel!*)   NEW(gPict);   gPict.notify := Dummy;   (* ***** *)   gPict.depth := BitsPerPixel;   (* make sure this is correct for your machine! *)   Pictures.Create(gPict, MaxX, MaxY, gPict.depth);   TurtleReset;      (* set default turtle values *)   ResetColor(black);END PGraph.