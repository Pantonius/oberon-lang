MODULE SortBench;(*      Rahmenprogramm zur Animation von Sortieralgorithmen   Fabian Mäser, 11.4.97   MacOberon 4.115 auf Macintosh Quadra 840AV   zuletzt geändert: 11.4.97*)IMPORT Input, Oberon, In, Out, PGraph, Random, Log;CONST   TicksPerSec = 300;   (* system-abhängig!!! -> Mac, Ceres: 300 - Sun, Windows: 1000 *)   MaxElems = 800;      (* maximale Anzahl Elemente im Sortier-array *)   X = 50;   Y = 50;    (* Rand... (grafische Darstellung) *)TYPE   StatsRec = RECORD      nuSwaps: LONGINT;         (* Anzahl "Swaps" (Vertauschungen) von Elementen *)      nuComparisons: LONGINT;   (* Anzahl Vergleiche von Elementen *)      ticks: LONGINT            (* Zeit in System-ticks *)   END;VAR   A: ARRAY MaxElems + 1 OF INTEGER;   (* + 1 dummy / Sentinel Element *)   len: INTEGER;                       (* aktuelle Groesse des Sortier-Arrays *)   stats: StatsRec;                    (* aktuelle Sort-Statistiken *)PROCEDURE WriteTicks (ticks: LONGINT);(* Zeitausgabe: ticks -> Sekunden *)VAR hs: LONGINT;BEGIN   Out.Int(ticks DIV TicksPerSec, 2);                                 (* seconds *)   Out.Char(".");   hs := ((ticks MOD TicksPerSec) * 100) DIV TicksPerSec;             (* 1/100 seconds *)   IF hs < 10 THEN Out.Char("0"); Out.Int(hs, 1) ELSE Out.Int(hs, 2) ENDEND WriteTicks;PROCEDURE ClearStats;(* Statistiken zuruecksetzten... *)BEGIN   stats.nuSwaps := 0; stats.nuComparisons := 0; stats.ticks := 0END ClearStats;PROCEDURE WriteStats(name: ARRAY OF CHAR);(* Statistiken ausgeben... *)BEGIN   Out.String(name); Out.Ln;   Out.String("   -  Swaps: "); Out.Int(stats.nuSwaps, 0); Out.Ln;   Out.String("   -  Comparisons: "); Out.Int(stats.nuComparisons, 0); Out.Ln;   Out.String("   -  time used: "); WriteTicks(stats.ticks); Out.String(" s"); Out.Ln;END WriteStats;PROCEDURE InitElems;(* Array-Elemente auf Startwerte setzen (= sortiert) *)VAR i: INTEGER;BEGIN   FOR i := 1 TO len DO A[i] := i ENDEND InitElems;PROCEDURE DrawState;(* den aktuellen Zustand des Sortierarrays zeichnen *)VAR   y0, i: INTEGER;BEGIN   y0 := PGraph.MaxY - (Y + len);   (* zeichne "am oberen Rand ausgerichtet" ... *)   i := len + 1;   PGraph.Clear;   PGraph.DrawLine(X, y0, X + i, y0, PGraph.white);   PGraph.DrawLine(X + i, y0, X + i, y0 + i, PGraph.white);   PGraph.DrawLine(X + i, y0 + i, X, y0 + i, PGraph.white);   PGraph.DrawLine(X, y0 + i, X, y0, PGraph.white);   FOR i := 1 TO len DO      PGraph.Dot(i + X, A[i] + y0, PGraph.white);   END;   PGraph.FlushAll;   (* update all graph viewers *)END DrawState;   PROCEDURE Swap(i, j: INTEGER; show: BOOLEAN);(*   vertauscht Elemente i und j und erhoeht den Swap-Zaehler   show -> grafische Animation des Tausches*)VAR y0, tmp: INTEGER;BEGIN   y0 := PGraph.MaxY - (Y + len);   IF show THEN      PGraph.Dot(i + X, A[i] + y0, PGraph.black);      PGraph.Dot(j + X, A[j] + y0, PGraph.black);      PGraph.Flush(i + X, A[i] + y0, 1, 1);   (* update all graph viewers *)      PGraph.Flush(j + X, A[j] + y0, 1, 1);   END;   tmp := A[i];   A[i] := A[j];   A[j] := tmp;   IF show THEN      PGraph.Dot(i + X, A[i] + y0, PGraph.white);      PGraph.Dot(j + X, A[j] + y0, PGraph.white);      PGraph.Flush(i + X, A[i] + y0, 1, 1);   (* update all graph viewers again... *)      PGraph.Flush(j + X, A[j] + y0, 1, 1);   END;   INC(stats.nuSwaps)END Swap;PROCEDURE Less(el1, el2: INTEGER): BOOLEAN;(* vergleiche Elemente "el1" und "el2" und erhoehe den Comparisons-Zaehler *)BEGIN   INC(stats.nuComparisons); RETURN (el1 < el2)END Less;(* ------------------------------- Sortier-Algorithmen ------------------------------ *)(*   - Sortier-Array A wird jeweils als Parameter uebergeben:      - erlaubt Betrachtung der Algorithmen losgeloest vom Grafik-Programm      - Erweiterung / Auftrennen in mehrere Module einfach moeglich   - gezaehlt werden nur Vergleiche mit Array-Elementen (mit Proc. "Less")*)PROCEDURE RandomSort(VAR A: ARRAY OF INTEGER; len: INTEGER; VAR percentage: REAL; show: BOOLEAN);(* waehle zwei zufaellige Elemente und vertausche, falls "guenstig" - Evolution =^ *)(* percentage -> Prozentsatz der "guenstig gewaehlten" Elemente *)VAR   i, j, c: INTEGER;   tries, succs: LONGINT;   PROCEDURE Sorted(): BOOLEAN;   (* Orakel...  *)   VAR i: INTEGER;   BEGIN      FOR i := 1 TO len - 1 DO         IF A[i + 1] < A[i] THEN RETURN FALSE END   (* Vergleiche nicht gezaehlt! *)      END;      RETURN TRUE   END Sorted;BEGIN   tries := 0; succs := 0;   REPEAT      FOR c := 1 TO 100 DO         i := Random.Int(len - 1) + 1;   j := Random.Int(len - 1) + 1;         INC(tries);         IF (i < j) & Less(A[j], A[i]) OR (i > j) & Less(A[i], A[j]) THEN            INC(succs);            Swap(i, j, show);         END      END   UNTIL (Input.Available() # 0) OR Sorted();   (* Abbruch bei keyboard input *)   IF tries # 0 THEN percentage := 100 * succs / tries ENDEND RandomSort;(* ---------------------------- Erweiterung M. Grossniklaus -------------------------- *)PROCEDURE QuickSort(VAR A: ARRAY OF INTEGER; iLo, iHi: INTEGER; show: BOOLEAN);VAR    Mid, Lo, Hi: INTEGER;BEGIN    Lo:=iLo;     Hi:=iHi;    Mid:=A[(Lo+Hi) DIV 2];         (* Bestimmung des Medians *)    REPEAT        WHILE Less(A[Lo], Mid) DO INC(Lo); END;        WHILE Less(Mid, A[Hi]) DO DEC(Hi); END;        IF Less(Lo, Hi+1) THEN     (* Die obere und untere Schranke sind beim Median angekommen *)            Swap(Lo, Hi, show);    (* Vertauschen der Elemente Lo und Hi *)            INC(Lo);            DEC(Hi);        END;    UNTIL Less(Hi, Lo);    IF Less(iLo, Hi) THEN QuickSort(A, iLo, Hi, show); END;    (* Rekursion: Sortieren des unteren Teils *)    IF Less(Lo, iHi) THEN QuickSort(A, Lo, iHi, show); END;    (* Rekursion: Sortieren des oberen Teils *)END QuickSort;PROCEDURE MergeSort(VAR A: ARRAY OF INTEGER; iLo, iHi: INTEGER; show: BOOLEAN);VAR    Mid: INTEGER;    y0, h, i, j, k: INTEGER;    Dummy: ARRAY MaxElems+1 OF  INTEGER;    (* Hilfsarray zum Verschmelzen der beiden Teile *)BEGIN    IF Less(iLo, iHi) THEN                  (* Falls nicht ist die Folge leer oder einelementig *)        Mid:=(iLo+iHi) DIV 2;               (* Mid ist die Mitte der Folge *)        MergeSort(A, iLo, Mid, show);       (* Rekursion: Sortieren der unteren Hälfte *)        MergeSort(A, Mid+1, iHi, show);     (* Rekursion: Sortieren der oberen Hälfte *)        i:=iLo;        j:=Mid+1;        k:=iLo;                                     (* Zählervariable des Dummy-Arrays *)        WHILE Less(i, Mid+1) & Less(j, iHi+1) DO    (* Die beiden Teile sind noch nicht erschöpft *)            IF Less(A[i], A[j]+1)                   (* Welches Element kommt zuerest ins neue Array? *)                THEN                    Dummy[k]:=A[i];                    INC(i);                ELSE                    Dummy[k]:=A[j];                    INC(j);            END;            INC(k);                            (* Nächstes Element im Dummy-Array *)        END;            IF Less(Mid, i)                THEN (* Das erste Teilarray ist erschöpft, übernimm das zweite *)                    FOR h:=j TO iHi DO Dummy[k+h-j]:=A[h]; END;                ELSE (* Das zweite Teilarray ist erschöpft, übernimm das erste *)                    FOR h:=i TO Mid DO Dummy[k+h-i]:=A[h]; END;            END;            y0:=PGraph.MaxY-(Y+len);            FOR h:=iLo TO iHi DO                 IF show THEN                    PGraph.Dot(h+X,A[h]+y0,PGraph.black);                    PGraph.Flush(h+X,A[h]+y0,1,1);                END;                A[h]:=Dummy[h]; END;    (*Zurückschreiben des Dummy-Arrays nach A *)                IF show THEN                    PGraph.Dot(h+X,A[h]+y0,PGraph.white);                    PGraph.Flush(h+X,A[h]+y0,1,1);                END;            END;    END;END MergeSort;            (* ---------------------------------- Commands ---------------------------------- *)PROCEDURE Init*;(*   liest die Anzahl Elemente ein...   am Anfang aufrufen sonst geht gar nix!*)VAR i: INTEGER;BEGIN   In.Open; In.Int(i);   IF In.Done & (i > 0) & (i <= MaxElems) THEN      len := i; InitElems; DrawState   ENDEND Init;PROCEDURE ReverseOrder*;(* verkehrte Sortierung...*)VAR i: INTEGER;BEGIN   FOR i := 1 TO len DO A[i] := (len + 1) - i END;   DrawStateEND ReverseOrder;PROCEDURE Randomize*;(* generiert eine zufaellige Startposition...*)VAR count, i, j: INTEGER;BEGIN   FOR count := 1 TO 800 DO      i := Random.Int(len - 1) + 1;   j := Random.Int(len - 1) + 1;      Swap(i, j, TRUE)   ENDEND Randomize;(* --------------------------------- RandomSort --------------------------------- *)PROCEDURE AnimateRandomSort*;VAR p: REAL;BEGIN   ClearStats;   stats.ticks := Oberon.Time();   Out.String("--- hit any key to interrupt RandomSort ---"); Out.Ln; Out.Ln;   RandomSort(A, len, p, TRUE);   stats.ticks := Oberon.Time() - stats.ticks;   WriteStats("RandomSort");   Out.String("   -  Successful tries: "); Out.Real(p, 7); Out.String(" %"); Out.Ln; Out.LnEND AnimateRandomSort;PROCEDURE MeasureRandomSort*;VAR p: REAL;BEGIN   ClearStats;   stats.ticks := Oberon.Time();   Out.String("--- hit any key to interrupt RandomSort ---"); Out.Ln; Out.Ln;   RandomSort(A, len, p, FALSE);   stats.ticks := Oberon.Time() - stats.ticks;   DrawState;   WriteStats("RandomSort");   Out.String("   -  Successful tries: "); Out.Real(p, 7); Out.String(" %"); Out.Ln; Out.LnEND MeasureRandomSort;(* ---------------------------------- QuickSort --------------------------------- *)PROCEDURE AnimateQuickSort*;BEGIN   ClearStats;   stats.ticks := Oberon.Time();   QuickSort(A, 1, len, TRUE);   stats.ticks := Oberon.Time() - stats.ticks;   WriteStats("QuickSort");END AnimateQuickSort;PROCEDURE MeasureQuickSort*;BEGIN   ClearStats;   stats.ticks := Oberon.Time();   QuickSort(A, 1, len, FALSE);   stats.ticks := Oberon.Time() - stats.ticks;   DrawState;   WriteStats("RandomSort");END MeasureQuickSort;(* ---------------------------------- MergeSort --------------------------------- *)PROCEDURE AnimateMergeSort*;BEGIN   ClearStats;   stats.ticks := Oberon.Time();   MergeSort(A, 1, len, TRUE);   stats.ticks := Oberon.Time() - stats.ticks;   DrawState;   WriteStats("MergeSort");END AnimateMergeSort;PROCEDURE MeasureMergeSort*;BEGIN   ClearStats;   stats.ticks := Oberon.Time();   MergeSort(A, 1, len, FALSE);   stats.ticks := Oberon.Time() - stats.ticks;   DrawState;   WriteStats("MergeSort");END MeasureMergeSort;(* ------------------------------- Hauptprogramm ------------------------------ *)BEGIN   len := 0;END SortBench.